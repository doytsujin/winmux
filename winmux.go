/*

    A version of win written in Go. That does terminal multiplexing.

*/

package main

import (
	"bytes"
	"code.google.com/p/goplan9/plan9/acme"
	"fmt"
	"log"
	"os"
//	"code.google.com/p/goplan9/draw"
//	"image"
	"github.com/rjkroege/winmux/ttypair"
	"sync"
)

type Q struct {
	// p int
	Win *acme.Win
	sync.Mutex
}

func main() {
	fmt.Print("hello from winmux\n");

	log.Print("hello!");

	// take a window id from the command line
	// I suppose it could come from the environment too
	
	log.Print(os.Args[0])

	var q Q
	var err error

	// TODO(rjkroege): look up a window by name if an argument is provided
	// and connect to it.
	if len(os.Args) > 1 {
		log.Fatal("write some code to lookup window by name and connect")
	} else {
		q.Win,err = acme.New()
	}
	if err != nil {
		log.Fatal("can't open the window? ", err.Error())
	}

	q.Win.Fprintf("body", "hi rob\n")
	acmetowin(&q)

	// TODO(rjkroege): start the function that receives from the pty and inserts into acme

	q.Win.CloseFiles()
	fmt.Print("bye\n")
}



func unknown(e *acme.Event) {
	log.Printf("unknown message %c%c\n", e.C1, e.C2);
}

// Replicates the functionality of the stdinproc in win.c
// Reads the event stream from acme, updates the window and
// echos the received content.
func acmetowin(q *Q) {
	debug := true


	// this needs to be adjustable as I change buffers. could destroy/reconnect?
	t := ttypair.New()
	
	// TODO(rjkroege): extract the initial value of Offset from the Acme buffer.
	// TODO(rjkroege): verify the correctness of this position.
	t.Move(len("hi rob\n"))

	for {
		if(debug) {
			a, b := t.Extent()
			log.Printf("typing[%d,%d), %s\n", a, b, t)
		}
		e, err := q.Win.ReadEvent()
		if err != nil {
			log.Fatal("event stream stopped? ", err.Error())
		}
		if(debug) {
			log.Printf("msg %c%c q[%d,%d)... ", e.C1, e.C2, e.Q0, e.Q1);
		}
		
		// queue for lock
		q.Lock();

		switch(e.C1) {
		default:	// be backwards compatible: ignore additional future messages.
			unknown(e)
		case 'E':	/* write to body or tag; can't affect us */
			switch(e.C2){
			case 'I', 'D':		/* body */
				if(debug) {
					log.Printf("shift typing %d... ", e.Q1 - e.Q0);
				}
				t.Move(e.Q1-e.Q0);
			case 'i', 'd':		/* tag */
			default:
				unknown(e)
			}
			break;

		case 'F':	/* generated by our actions; ignore */
		case 'K', 'M':		// Keyboard or Mouse actions that edit the file
			switch e.C2 {
			case 'I':	// text inserted into the body (This is a capital i)
				switch {
				case e.Nr == 1 && e.Text[0] == 0x7F:
					// handle delete characters: delete the character.
					// write addr, delete character
					log.Print("ship delete off to child\n")
//					char buf[1];
//					fsprint(addrfd, "#%ud,#%ud", e.Q0, e.Q1);
//					fswrite(datafd, "", 0);
//					buf[0] = 0x7F;
					// ship DEL off to child.
					t.UnbufferedWrite([]byte{0x7F})
				case t.Beforeslice(e.Q0):
					// Inserting before the final line. Doesn't affect the last line.
					if debug {
						log.Printf("shift typing %d... ", e.Q1-e.Q0);
					}
					t.Move(e.Q1-e.Q0);
				case t.Inslice(e.Q0):
					// Typing in the final line.
					if(debug) {
						log.Printf("type... ");
					}
					t.Type(e /* afd, dfd */);
				}
			case 'D':    // deleting text from the body
				n := t.Delete(e); 
				// TODO(rjkroege): Delete from the winslice should
				// automatically update the Offset in Winslice?
				t.Move(-n);
				if t.Israw() && t.Afterslice(e.Q1, n) {
					t.Sendbs(n);
				}
				break;
			case 'x',  'X':	// button 2 in the tag or body
				// TODO(rjkroege): Copy the text to the bottom.
				if(e.Flag & 1 != 0 || (e.C2=='x' && e.Nr==0)){
					/* send it straight back */
					q.Win.WriteEvent(e);
					break;
				}
				if bytes.Equal([]byte("cook"), e.Text) {
					log.Print("should set cook to 1 whatever that does.")
					t.Setcook(true)
					break;
				}
				if bytes.Equal([]byte("nocook"), e.Text) {
					log.Print("should clear cook")
					t.Setcook(false)
					break;
				}
				// Send stuff to child
				log.Printf("should send %s to child process\n", e.Text)
				// Shouldn't this also push the contents to the 
				// sendtochild(...)
			case 'l', 'L':	// button 3, tag or body
				/* just send it back */
				q.Win.WriteEvent(e);
				break;
			case 'd', 'i': // text deleted or inserted into the tag.
				break;
			default:
				unknown(e)
			}
		}
		// Release the lock.
		q.Unlock();
	}
}